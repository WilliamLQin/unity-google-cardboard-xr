// <auto-generated>
//     Generated by the protocol buffer compiler.  DO NOT EDIT!
//     source: cardboard_device.proto
// </auto-generated>
#pragma warning disable 1591, 0612, 3021
#region Designer generated code

using pb = global::Google.Protobuf;
using pbc = global::Google.Protobuf.Collections;
using pbr = global::Google.Protobuf.Reflection;
using scg = global::System.Collections.Generic;
namespace CardboardXR {

  /// <summary>Holder for reflection information generated from cardboard_device.proto</summary>
  public static partial class CardboardDeviceReflection {

    #region Descriptor
    /// <summary>File descriptor for cardboard_device.proto</summary>
    public static pbr::FileDescriptor Descriptor {
      get { return descriptor; }
    }
    private static pbr::FileDescriptor descriptor;

    static CardboardDeviceReflection() {
      byte[] descriptorData = global::System.Convert.FromBase64String(
          string.Concat(
            "ChZjYXJkYm9hcmRfZGV2aWNlLnByb3RvEhBNb2JmaXNoQ2FyZGJvYXJkIvwD",
            "CgxEZXZpY2VQYXJhbXMSDgoGdmVuZG9yGAEgASgJEg0KBW1vZGVsGAIgASgJ",
            "Eh8KF3NjcmVlbl90b19sZW5zX2Rpc3RhbmNlGAMgASgCEhsKE2ludGVyX2xl",
            "bnNfZGlzdGFuY2UYBCABKAISKQodbGVmdF9leWVfZmllbGRfb2Zfdmlld19h",
            "bmdsZXMYBSADKAJCAhABElgKEnZlcnRpY2FsX2FsaWdubWVudBgLIAEoDjI0",
            "Lk1vYmZpc2hDYXJkYm9hcmQuRGV2aWNlUGFyYW1zLlZlcnRpY2FsQWxpZ25t",
            "ZW50VHlwZToGQk9UVE9NEh0KFXRyYXlfdG9fbGVuc19kaXN0YW5jZRgGIAEo",
            "AhIjChdkaXN0b3J0aW9uX2NvZWZmaWNpZW50cxgHIAMoAkICEAESSQoOcHJp",
            "bWFyeV9idXR0b24YDCABKA4yKS5Nb2JmaXNoQ2FyZGJvYXJkLkRldmljZVBh",
            "cmFtcy5CdXR0b25UeXBlOgZNQUdORVQiOAoVVmVydGljYWxBbGlnbm1lbnRU",
            "eXBlEgoKBkJPVFRPTRAAEgoKBkNFTlRFUhABEgcKA1RPUBACIkEKCkJ1dHRv",
            "blR5cGUSCAoETk9ORRAAEgoKBk1BR05FVBABEgkKBVRPVUNIEAISEgoOSU5E",
            "SVJFQ1RfVE9VQ0gQA0IvChpjb20uZ29vZ2xlLmNhcmRib2FyZC5wcm90b0IP",
            "Q2FyZGJvYXJkRGV2aWNlSAM="));
      descriptor = pbr::FileDescriptor.FromGeneratedCode(descriptorData,
          new pbr::FileDescriptor[] { },
          new pbr::GeneratedClrTypeInfo(null, null, new pbr::GeneratedClrTypeInfo[] {
            new pbr::GeneratedClrTypeInfo(typeof(global::CardboardXR.DeviceParams), global::CardboardXR.DeviceParams.Parser, new[]{ "Vendor", "Model", "ScreenToLensDistance", "InterLensDistance", "LeftEyeFieldOfViewAngles", "VerticalAlignment", "TrayToLensDistance", "DistortionCoefficients", "PrimaryButton" }, null, new[]{ typeof(global::CardboardXR.DeviceParams.Types.VerticalAlignmentType), typeof(global::CardboardXR.DeviceParams.Types.ButtonType) }, null, null)
          }));
    }
    #endregion

  }
  #region Messages
  /// <summary>
  ///*
  /// Message describing properties of a VR head mount device (HMD) which uses an
  /// interchangeable smartphone as a display (e.g. Google Cardboard).
  ///
  /// While some properties are certain (e.g. inter_lens_distance), others
  /// represent nominal values which may be refined depending on context (e.g.
  /// viewport_angles).
  ///
  /// Lengths are in meters unless noted otherwise.  Fields are _required_
  /// unless noted otherwise.
  ///
  /// Some context on why this set of parameters are deemed necessary and
  /// sufficient:
  ///    * FOV scale can be reasonably approximated from lens-to-screen distance
  ///      and display size (i.e. knowing lens focal length isn't crucial).
  ///    * Lenses are assumed to be horizontally centered with respect to
  ///      display.
  ///    * The display is not necessarily vertically centered.  For interchangeable
  ///      phones where the device rests against a tray, we can derive
  ///      the vertical offset from tray-to-lens height along with phone-specific
  ///      bezel and screen sizes (supplied separately).
  /// </summary>
  public sealed partial class DeviceParams : pb::IMessage<DeviceParams> {
    private static readonly pb::MessageParser<DeviceParams> _parser = new pb::MessageParser<DeviceParams>(() => new DeviceParams());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<DeviceParams> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::CardboardXR.CardboardDeviceReflection.Descriptor.MessageTypes[0]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public DeviceParams() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public DeviceParams(DeviceParams other) : this() {
      _hasBits0 = other._hasBits0;
      vendor_ = other.vendor_;
      model_ = other.model_;
      screenToLensDistance_ = other.screenToLensDistance_;
      interLensDistance_ = other.interLensDistance_;
      leftEyeFieldOfViewAngles_ = other.leftEyeFieldOfViewAngles_.Clone();
      verticalAlignment_ = other.verticalAlignment_;
      trayToLensDistance_ = other.trayToLensDistance_;
      distortionCoefficients_ = other.distortionCoefficients_.Clone();
      primaryButton_ = other.primaryButton_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public DeviceParams Clone() {
      return new DeviceParams(this);
    }

    /// <summary>Field number for the "vendor" field.</summary>
    public const int VendorFieldNumber = 1;
    private readonly static string VendorDefaultValue = "";

    private string vendor_;
    /// <summary>
    /// String identifying the device's vendor (e.g. "Google, Inc.").
    /// A device's [vendor, model] pair is expected to be globally unique.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Vendor {
      get { return vendor_ ?? VendorDefaultValue; }
      set {
        vendor_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "vendor" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasVendor {
      get { return vendor_ != null; }
    }
    /// <summary>Clears the value of the "vendor" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearVendor() {
      vendor_ = null;
    }

    /// <summary>Field number for the "model" field.</summary>
    public const int ModelFieldNumber = 2;
    private readonly static string ModelDefaultValue = "";

    private string model_;
    /// <summary>
    /// String identifying the device's model, including revision info if
    /// needed (e.g. "Cardboard v1").  A device's [vendor, model] pair is
    /// expected to be globally unique.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Model {
      get { return model_ ?? ModelDefaultValue; }
      set {
        model_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }
    /// <summary>Gets whether the "model" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasModel {
      get { return model_ != null; }
    }
    /// <summary>Clears the value of the "model" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearModel() {
      model_ = null;
    }

    /// <summary>Field number for the "screen_to_lens_distance" field.</summary>
    public const int ScreenToLensDistanceFieldNumber = 3;
    private readonly static float ScreenToLensDistanceDefaultValue = 0F;

    private float screenToLensDistance_;
    /// <summary>
    /// Distance from the display screen to the optical center of lenses.
    /// This is a required field for distortion rendering, and must be positive.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float ScreenToLensDistance {
      get { if ((_hasBits0 & 1) != 0) { return screenToLensDistance_; } else { return ScreenToLensDistanceDefaultValue; } }
      set {
        _hasBits0 |= 1;
        screenToLensDistance_ = value;
      }
    }
    /// <summary>Gets whether the "screen_to_lens_distance" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasScreenToLensDistance {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "screen_to_lens_distance" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearScreenToLensDistance() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "inter_lens_distance" field.</summary>
    public const int InterLensDistanceFieldNumber = 4;
    private readonly static float InterLensDistanceDefaultValue = 0F;

    private float interLensDistance_;
    /// <summary>
    /// Horizontal distance between optical center of the lenses.
    /// This is a required field for distortion rendering, and must be positive.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float InterLensDistance {
      get { if ((_hasBits0 & 2) != 0) { return interLensDistance_; } else { return InterLensDistanceDefaultValue; } }
      set {
        _hasBits0 |= 2;
        interLensDistance_ = value;
      }
    }
    /// <summary>Gets whether the "inter_lens_distance" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasInterLensDistance {
      get { return (_hasBits0 & 2) != 0; }
    }
    /// <summary>Clears the value of the "inter_lens_distance" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearInterLensDistance() {
      _hasBits0 &= ~2;
    }

    /// <summary>Field number for the "left_eye_field_of_view_angles" field.</summary>
    public const int LeftEyeFieldOfViewAnglesFieldNumber = 5;
    private static readonly pb::FieldCodec<float> _repeated_leftEyeFieldOfViewAngles_codec
        = pb::FieldCodec.ForFloat(42);
    private readonly pbc::RepeatedField<float> leftEyeFieldOfViewAngles_ = new pbc::RepeatedField<float>();
    /// <summary>
    /// Four-element tuple (left, right, bottom, top) of left eye's view extent
    /// angles relative to center, assuming the following:
    ///     * eye is aligned with optical center of lens
    ///     * display screen is equal or larger than extents viewable through lens
    ///     * nominal eye-to-lens distance
    ///     * mirrored field of view will be applied to the right eye
    /// These values are essentially used as an optimization to avoid rendering
    /// pixels which can't be seen.
    /// This is a required field for distortion rendering, and angles must be
    /// positive.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<float> LeftEyeFieldOfViewAngles {
      get { return leftEyeFieldOfViewAngles_; }
    }

    /// <summary>Field number for the "vertical_alignment" field.</summary>
    public const int VerticalAlignmentFieldNumber = 11;
    private readonly static global::CardboardXR.DeviceParams.Types.VerticalAlignmentType VerticalAlignmentDefaultValue = global::CardboardXR.DeviceParams.Types.VerticalAlignmentType.Bottom;

    private global::CardboardXR.DeviceParams.Types.VerticalAlignmentType verticalAlignment_;
    /// <summary>
    /// Set according to vertical alignment strategy-- see enum comments above.
    /// NOTE: If you set this to CENTER, see special instructions for the
    /// tray_to_lens_distance field below.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::CardboardXR.DeviceParams.Types.VerticalAlignmentType VerticalAlignment {
      get { if ((_hasBits0 & 8) != 0) { return verticalAlignment_; } else { return VerticalAlignmentDefaultValue; } }
      set {
        _hasBits0 |= 8;
        verticalAlignment_ = value;
      }
    }
    /// <summary>Gets whether the "vertical_alignment" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasVerticalAlignment {
      get { return (_hasBits0 & 8) != 0; }
    }
    /// <summary>Clears the value of the "vertical_alignment" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearVerticalAlignment() {
      _hasBits0 &= ~8;
    }

    /// <summary>Field number for the "tray_to_lens_distance" field.</summary>
    public const int TrayToLensDistanceFieldNumber = 6;
    private readonly static float TrayToLensDistanceDefaultValue = 0F;

    private float trayToLensDistance_;
    /// <summary>
    /// If the phone is aligned vertically within the device by resting against
    /// a fixed top or bottom tray, this is the distance from the tray to
    /// optical center of the lenses.
    /// This is a required field for distortion rendering, and must be positive.
    /// NOTE: Due to a bug in initial versions of the SDK's, this field
    /// must be set explicitly to .035 when vertical_alignment = CENTER.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float TrayToLensDistance {
      get { if ((_hasBits0 & 4) != 0) { return trayToLensDistance_; } else { return TrayToLensDistanceDefaultValue; } }
      set {
        _hasBits0 |= 4;
        trayToLensDistance_ = value;
      }
    }
    /// <summary>Gets whether the "tray_to_lens_distance" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasTrayToLensDistance {
      get { return (_hasBits0 & 4) != 0; }
    }
    /// <summary>Clears the value of the "tray_to_lens_distance" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearTrayToLensDistance() {
      _hasBits0 &= ~4;
    }

    /// <summary>Field number for the "distortion_coefficients" field.</summary>
    public const int DistortionCoefficientsFieldNumber = 7;
    private static readonly pb::FieldCodec<float> _repeated_distortionCoefficients_codec
        = pb::FieldCodec.ForFloat(58);
    private readonly pbc::RepeatedField<float> distortionCoefficients_ = new pbc::RepeatedField<float>();
    /// <summary>
    /// Coefficients Ki for pincushion distortion function which maps
    /// from position on real screen to virtual screen (i.e. texture) relative
    /// to optical center:
    ///
    ///    p' = p (1 + K1 r^2 + K2 r^4 + ... + Kn r^(2n))
    ///
    /// where r is the distance in tan-angle units from the optical center,
    /// p the input point, and p' the output point.  Tan-angle units can be
    /// computed as distance on the screen divided by distance from the
    /// virtual eye to the screen.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<float> DistortionCoefficients {
      get { return distortionCoefficients_; }
    }

    /// <summary>Field number for the "primary_button" field.</summary>
    public const int PrimaryButtonFieldNumber = 12;
    private readonly static global::CardboardXR.DeviceParams.Types.ButtonType PrimaryButtonDefaultValue = global::CardboardXR.DeviceParams.Types.ButtonType.Magnet;

    private global::CardboardXR.DeviceParams.Types.ButtonType primaryButton_;
    /// <summary>
    /// Specify primary input mechanism of the HMD.  Intended for advisory
    /// purposes only, to address simple questions such as "can HMD
    /// be used with apps requiring a physical button event?" or "what icon
    /// should be used to represent button action to the user?".
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::CardboardXR.DeviceParams.Types.ButtonType PrimaryButton {
      get { if ((_hasBits0 & 16) != 0) { return primaryButton_; } else { return PrimaryButtonDefaultValue; } }
      set {
        _hasBits0 |= 16;
        primaryButton_ = value;
      }
    }
    /// <summary>Gets whether the "primary_button" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasPrimaryButton {
      get { return (_hasBits0 & 16) != 0; }
    }
    /// <summary>Clears the value of the "primary_button" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearPrimaryButton() {
      _hasBits0 &= ~16;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as DeviceParams);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(DeviceParams other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Vendor != other.Vendor) return false;
      if (Model != other.Model) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(ScreenToLensDistance, other.ScreenToLensDistance)) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(InterLensDistance, other.InterLensDistance)) return false;
      if(!leftEyeFieldOfViewAngles_.Equals(other.leftEyeFieldOfViewAngles_)) return false;
      if (VerticalAlignment != other.VerticalAlignment) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(TrayToLensDistance, other.TrayToLensDistance)) return false;
      if(!distortionCoefficients_.Equals(other.distortionCoefficients_)) return false;
      if (PrimaryButton != other.PrimaryButton) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (HasVendor) hash ^= Vendor.GetHashCode();
      if (HasModel) hash ^= Model.GetHashCode();
      if (HasScreenToLensDistance) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(ScreenToLensDistance);
      if (HasInterLensDistance) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(InterLensDistance);
      hash ^= leftEyeFieldOfViewAngles_.GetHashCode();
      if (HasVerticalAlignment) hash ^= VerticalAlignment.GetHashCode();
      if (HasTrayToLensDistance) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(TrayToLensDistance);
      hash ^= distortionCoefficients_.GetHashCode();
      if (HasPrimaryButton) hash ^= PrimaryButton.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (HasVendor) {
        output.WriteRawTag(10);
        output.WriteString(Vendor);
      }
      if (HasModel) {
        output.WriteRawTag(18);
        output.WriteString(Model);
      }
      if (HasScreenToLensDistance) {
        output.WriteRawTag(29);
        output.WriteFloat(ScreenToLensDistance);
      }
      if (HasInterLensDistance) {
        output.WriteRawTag(37);
        output.WriteFloat(InterLensDistance);
      }
      leftEyeFieldOfViewAngles_.WriteTo(output, _repeated_leftEyeFieldOfViewAngles_codec);
      if (HasTrayToLensDistance) {
        output.WriteRawTag(53);
        output.WriteFloat(TrayToLensDistance);
      }
      distortionCoefficients_.WriteTo(output, _repeated_distortionCoefficients_codec);
      if (HasVerticalAlignment) {
        output.WriteRawTag(88);
        output.WriteEnum((int) VerticalAlignment);
      }
      if (HasPrimaryButton) {
        output.WriteRawTag(96);
        output.WriteEnum((int) PrimaryButton);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (HasVendor) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Vendor);
      }
      if (HasModel) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Model);
      }
      if (HasScreenToLensDistance) {
        size += 1 + 4;
      }
      if (HasInterLensDistance) {
        size += 1 + 4;
      }
      size += leftEyeFieldOfViewAngles_.CalculateSize(_repeated_leftEyeFieldOfViewAngles_codec);
      if (HasVerticalAlignment) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) VerticalAlignment);
      }
      if (HasTrayToLensDistance) {
        size += 1 + 4;
      }
      size += distortionCoefficients_.CalculateSize(_repeated_distortionCoefficients_codec);
      if (HasPrimaryButton) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) PrimaryButton);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(DeviceParams other) {
      if (other == null) {
        return;
      }
      if (other.HasVendor) {
        Vendor = other.Vendor;
      }
      if (other.HasModel) {
        Model = other.Model;
      }
      if (other.HasScreenToLensDistance) {
        ScreenToLensDistance = other.ScreenToLensDistance;
      }
      if (other.HasInterLensDistance) {
        InterLensDistance = other.InterLensDistance;
      }
      leftEyeFieldOfViewAngles_.Add(other.leftEyeFieldOfViewAngles_);
      if (other.HasVerticalAlignment) {
        VerticalAlignment = other.VerticalAlignment;
      }
      if (other.HasTrayToLensDistance) {
        TrayToLensDistance = other.TrayToLensDistance;
      }
      distortionCoefficients_.Add(other.distortionCoefficients_);
      if (other.HasPrimaryButton) {
        PrimaryButton = other.PrimaryButton;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            Vendor = input.ReadString();
            break;
          }
          case 18: {
            Model = input.ReadString();
            break;
          }
          case 29: {
            ScreenToLensDistance = input.ReadFloat();
            break;
          }
          case 37: {
            InterLensDistance = input.ReadFloat();
            break;
          }
          case 42:
          case 45: {
            leftEyeFieldOfViewAngles_.AddEntriesFrom(input, _repeated_leftEyeFieldOfViewAngles_codec);
            break;
          }
          case 53: {
            TrayToLensDistance = input.ReadFloat();
            break;
          }
          case 58:
          case 61: {
            distortionCoefficients_.AddEntriesFrom(input, _repeated_distortionCoefficients_codec);
            break;
          }
          case 88: {
            VerticalAlignment = (global::CardboardXR.DeviceParams.Types.VerticalAlignmentType) input.ReadEnum();
            break;
          }
          case 96: {
            PrimaryButton = (global::CardboardXR.DeviceParams.Types.ButtonType) input.ReadEnum();
            break;
          }
        }
      }
    }

    #region Nested types
    /// <summary>Container for nested types declared in the DeviceParams message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static partial class Types {
      public enum VerticalAlignmentType {
        /// <summary>
        /// phone rests against a fixed bottom tray
        /// </summary>
        [pbr::OriginalName("BOTTOM")] Bottom = 0,
        /// <summary>
        /// phone screen assumed to be centered w.r.t. lenses
        /// </summary>
        [pbr::OriginalName("CENTER")] Center = 1,
        /// <summary>
        /// phone rests against a fixed top tray
        /// </summary>
        [pbr::OriginalName("TOP")] Top = 2,
      }

      public enum ButtonType {
        /// <summary>
        /// No physical button, and touch screen is not easily accessible.
        /// </summary>
        [pbr::OriginalName("NONE")] None = 0,
        /// <summary>
        /// HMD has integrated magnet switch similar to original Cardboard.
        /// </summary>
        [pbr::OriginalName("MAGNET")] Magnet = 1,
        /// <summary>
        /// At least a portion of touch screen is easily accessible to user for taps.
        /// </summary>
        [pbr::OriginalName("TOUCH")] Touch = 2,
        /// <summary>
        /// Touch screen is triggered indirectly via integrated button on the HMD.
        /// </summary>
        [pbr::OriginalName("INDIRECT_TOUCH")] IndirectTouch = 3,
      }

    }
    #endregion

  }

  #endregion

}

#endregion Designer generated code
